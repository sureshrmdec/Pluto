 // 1. 搞定简单题目，别墨迹，重点花在不会的上面, 太难的放弃，应该phone interview不会考
 // 2. Data Wrangling 看一下，redix 特性, Mongo 特性准备
 // 3. Pig grunt的几个弄会， 简历， Yahoo 搞定就OK
 
 
 MapReduce提供Partitioner接口，它的作用就是根据key或value及reduce的数量来决定当前的这对输出数据最终应该交由哪个reduce task处理
 默认对key hash后再以reduce task数量取模
 
 
 这个从内存往磁盘写数据的过程被称为Spill，比如
 Mapper
 |
 Partition --> 决定去哪个Reducer，这个partition和信息再一起了
 |
 Memory (缓存区，等待其他同类的，到时候一起送到Reducer，降低IO开销)
 |
 | Spill Memory 撑爆了，写入硬盘
 |
 Combinar 跟Reduce一样，不过是单机的
 |
 Sort 排序
 |
 |
 Merge(Mapper) 很多溢写文件要合并，一起发送Reducer， ["aaa", 5, 8 ,2]
 |
 Merge(Reducer)不断拉文件,合并，可能在内存，可能在磁盘
 |
 Reducer
 |
 Merge 因为多个reduce 任务输出的数量都属于不同的partition, 因为结果结束的key不会重复. 
 合并reduce的输出文件就可以得到最终结果
 
 
 5. abstract class和interface的区别
 从NoSql跟关系数据库的比较开始发散，扩展了很多问题，比如设计通信协议，如何load balance，如何添加新服务器rebalance，如何避免staleness，如何上锁。 
http://blog.csdn.net/b271737818/article/details/3950245
  
6. 电面
7. 进程线程区别
8. mutex semophore区别
9. 进程间通信种类
10. 实现一个单链表 

11. 消除死锁

互斥（Mutual exclusion）：存在这样一种资源，它在某个时刻只能被分配给一个执行绪（也称为线程）使用；
持有（Hold and wait）：当请求的资源已被占用从而导致执行绪阻塞时，资源占用者不但无需释放该资源，而且还可以继续请求更多资源；
不可剥夺（No preemption）：执行绪获得到的互斥资源不可被强行剥夺，换句话说，只有资源占用者自己才能释放资源；
环形等待（Circular wait）：若干执行绪以不同的次序获取互斥资源，从而形成环形等待的局面，想象在由多个执行绪组成的环形链中，每个执行绪都在等待下一个执行绪释放它持有的资源。

解除死锁的必要条件
不难看出，在死锁的四个必要条件中，第二、三和四项条件比较容易消除。通过引入事务机制，往往可以消除第二、三两项条件，方法是将所有上锁操作均作为事务对待，一旦开始上锁，即确保全部操作均可回退，同时通过锁管理器检测死锁，并剥夺资源（回退事务）。这种做法有时会造成较大开销，而且也需要对上锁模式进行较多改动。
消除第四项条件是比较容易且代价较低的办法。具体来说这种方法约定：上锁的顺序必须一致。具体来说，我们人为地给锁指定一种类似“水位”的方向性属性。无论已持有任何锁，该执行绪所有的上锁操作，必须按照一致的先后顺序从低到高（或从高到低）进行，且在一个系统中，只允许使用一种先后次序。
请注意，放锁的顺序并不会导致死锁。也就是说，尽管按照 锁A, 锁B, 放A, 放B 这样的顺序来进行锁操作看上去有些怪异，但是只要大家都按先A后B的顺序上锁，便不会导致死锁。
  
  
  1 使用事务时，尽量缩短事务的逻辑处理过程，及早提交或回滚事务； (细化处理逻辑，执行一段逻辑后便回滚或者提交，然后再执行其它逻辑，直到事物执行完毕提交)
2 设置死锁超时参数为合理范围，如：3分钟-10分种；超过时间，自动放弃本次操作，避免进程悬挂；
3 优化程序，检查并避免死锁现象出现； 
4 .对所有的脚本和SP都要仔细测试，在正是版本之前。 
5 所有的SP都要有错误处理（通过@error） 
6 一般不要修改SQL SERVER事务的默认级别。不推荐强行加锁
  
  
  